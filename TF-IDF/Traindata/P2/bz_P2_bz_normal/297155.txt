User-Agent:       Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 1.1.4322; .NET CLR 3.0.04506.30; .NET CLR 3.0.04506.648; OfficeLiveConnector.1.3; OfficeLivePatch.0.0; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)
Build Identifier: 1.1.3

By explicitly asking that new object be cached they are not found in the cache anymore when using ObjectLevelReadQuery.CheckCacheOnly.

Because code in ExpressionQueryMechanism.checkCacheForObject (very long method making difficult to fix by subclassing) is skipping code if not conforming:

   if (conforming) {
            if (cachedObject == null) {
                if (selectionKey != null) {
                    if (!uow.shouldNewObjectsBeCached()) {
                        cachedObject = uow.getObjectFromNewObjects(query.getReferenceClass(), selectionKey);
                    }

This underline that the concept represented by following constants are not always exclusive. In particular, there is missing functionality on doing query on specific part of the cache.
    public static final int DoNotCheckCache = 0;
    public static final int CheckCacheByExactPrimaryKey = 1;
    public static final int CheckCacheByPrimaryKey = 2;
    public static final int CheckCacheThenDatabase = 3;
    public static final int CheckCacheOnly = 4;
    public static final int ConformResultsInUnitOfWork = 5;




Reproducible: Always

Steps to Reproduce:
Pseudo code failing:

MyObject obj = new MyObject();
uow.setShouldNewObjectsBeCached(true);
uow.registerNewObject(obj);
ReadObjectQuery readObjectQuery = new ReadObjectQuery(obj.getClass());
readObjectQuery.setCacheUsage(ReadObjectQuery.CheckCacheOnly);
readObjectQuery.setSelectionKey(obj.getId());
assertNotNull(uow.executeQuery(readObjectQuery) );