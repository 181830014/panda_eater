There are two possible deadlock scenerios for sequencing:

- If you do not use a sequence connection pool, the sequencing code is currently acquiring a lock before getting its connection (from the write pool), but if the pool is maxed it will wait, if another thread is in an early transaction and also needs the same sequence it will wait on the sequence lock.  This will cause a deadlock, or return an error if the pool has a max wait.  The code should be fixed, or at least improved to acquire the lock after checking if it needs to wait (does not wait if in an early transaction).  The user can also resolve this deadlock by increasing the max number of connections, and it is less likely with a large sequence preallocation size.

- If you use a sequence connection pool with a shared pool (also used for read/write, such as the non-jta-datasource (now the default)), if the pool is maxed, and you need to allocate a sequence, it will deadlock, or return an error if the pool has a max wait.  The solution is for the user to configure either a separate sequence connection pool, not use a sequence connection pool (see above), or increase the max number of connections or preallocation size.