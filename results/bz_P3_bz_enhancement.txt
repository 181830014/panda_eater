7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569407

The list of the committers (and optionally the companies) that have contributed to an eclipse release should appear in the about dialog to motivate committers and to install a kind of recognition. 

In parallel, even bug reporters could be mentioned even if they are not committers.

May be it will need to sign an agreement for that.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569584

-- Configuration Details --
Product: Eclipse IDE 4.18.0.20201105-1200 (org.eclipse.epp.package.committers.product)Installed Features:
 org.eclipse.platform 4.18.0.v20201028-2203

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=568946

Created attachment 284813 [details]
The marked element should be treated as if it does not exist

It should be supported to prevent the selection of a single item in a Table (or List or Combo ... but I stick to Table first). 

That is, trying to select this element should treat it as being invisible, simply ignoring it and overleap it. A clean example can be seen in in the "Open Type" Dialog (see enclosed screenshot). The marked item should be treated as if it does not exist. 

Android e.g. seems to support this behavior (http://burnignorance.com/android-apps-development/how-to-disable-selection-of-selected-items-in-a-listview/) - while for Eclipse this does not seem possible at the moment (according to https://www.eclipse.org/forums/index.php/t/146776/) 

org.eclipse.swt.widgets.Table#tableViewSelectionIsChanging seems to be a starting point to add the resp. behaviour.

I see two solutions:

Extending the ContentProvider to be queried (e.g. #isSelectable) or add a new Event to be thrown like a PreSelectionEvent where Event.doIt = false would be considered. (If this is possible at all to implement)

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569210

On the C side there is a feature called "unix domain sockets", that is not directly available from Java.
This feature lets unix processes exchange network messages without the messages ever touching the network cards, if they are located in the same machine.

While Java is not able to use this feature ... thanks to the architecture of how PTC -s are started on Titan's Java side, it might be possible to create a similar alternative.
For PTC -s running inside the same JVM it might be possible to realize, that they are inside the same JVM (as we have an outside view on the setup during execution) and could create connections between them, that exchange message without sending them out to the network cards.
This could create some measurable performance for inter-PTC communication (when they are on the same JVM).
And actually might also be useful in practice:
- in the case of smaller tests, all PTC -s might be running on the same machine/JVM for cost reasons.
- in case of larger, more distributed test scenarios, where there are many PTC -s running in parallel ... there is a good chance that some of them will be on the same machine (user can also affect this intentionally), leting us reduce the overhead of internal communications significantly.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569035

as discussed in https://bugs.eclipse.org/bugs/show_bug.cgi?id=543231 and https://www.eclipse.org/forums/index.php/m/1834967/#msg_1834967 it is not obvious how to save a url model to a file  with stereotypes applied. There are several gotchas as discussed in the forum thread thread above. I have modified  IntroductionToUMLProfiles.java to include examples of hoot save a model with stereotypes applied in Java, the code is at https://www.eclipse.org/forums/index.php?t=getfile&id=39380&. To be complete and reasonable this most probably ought to have some updated url to show hoot do it in the ui (though I am not sure how that works...)

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569675

The product catalog for version "Eclipse IDE for Enterprise Java Developers (2020-12)" (https://git.eclipse.org/c/oomph/org.eclipse.oomph.git/tree/setups/org.eclipse.products.setup#n1368) does not include the feature "org.eclipse.m2e.lemminx.feature.feature.group" while it is included in the regular "Eclipse IDE for Java Developers (2020-12)" 
 (https://git.eclipse.org/c/oomph/org.eclipse.oomph.git/tree/setups/org.eclipse.products.setup#n106)

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569111



7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569217

One of the main features missing from the first implementation of the Java Native Main Controller is the support for debugging commands present in mctr_cli.

All of them can be supported, they just could not yet fit into the timeframe.

Supporting them, would enable to user, to debug how their tests are executing, while they are executing. Check where the flow of execution is at any point in time in the code.
Check the actual value of variables.
Step through their code step-by-step, carefully monitoring the system to find bugs.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569205

On the Java side of the toolset the build time is so fast, it might enable features that the C side could not offer.

For example if the project is already compiled and the user starts and execution with some configuration file: it would be possible to create a temporal copy of compiled code, where the module parameter settings from the actual config file are automatically inserted in the code ... turning a module parameter value statically known (just like constants) ... enabling much more runtime optimizations.

This could help improve the startup time of projects signifficantly, since effectively all code executed before the first message arrives, could be calculated in compilation time ... taking a heavy load from execution time.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569700

Bug 535689 relates a problem due to using a vintage Tycho 1.4.0 that was obscurely diagnosed as an illegal reflective operation in httpclient4.

The recent churning of Java versions and deprecations within Eclipse make the nominally free choice of Java, Eclipse, Tycho, Maven versions a far from independent choice. Many bad combinations crash obviously. But more subtle incompatibilities give really obscure diagnosis.

Suggest: something in Tycho, ? the maven-enforcer ?, could issue helpful warnings about known subtly bad combinations?

NB The underlying metadata for this diagnosis must be version independent to avoid needing to upgrade the metadata to discover the need to upgrade the metadata. An evolving XML file should do, enumerating bad combinations with a reason text and override-able identity. A version inheritance policy is needed to avoid duplicating across versions.

NB Warnings are needed only for genuine incompatibility hazards, not for the developer's enthusiasm for the latest version.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569673

The TTF committee working on the TTCN-3 core standard has accepted the proposal for the @nodefault feature also for interleave -s (CR 7991).

Using the @nodefault modifier testers can use shorthand notations without the risk of activating the activated defaults.
The very reason for which we have a code smell detector in Titanium.

This means, that once this feature is accepted into the standard and implemented in the Designer plugin (semantic checking of TTCN-3 code) ... this code smell spotter will also need to be updated.
Otherwise:
- it would mark correct shorthand statements too as erroneous (false positive detection)
- propose a sub-optimal correction for the issue.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=568886

Provide org.eclipse.scout.rt.ldap module with functionality of authenticating scout user/account against LDAP server.

Initial information/example code:
https://www.eclipse.org/forums/index.php/t/1104155/

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569211

It might be worth a try to see if Titan could use GPUs to speed up the encoding/decoding of messages (at least for some encodings and some protocols).

Most of the time, the actual real-life encoding/decoding needed to be done is not very complicated.
And for many messages or message parts, a GPU based implementation might be able to do the work much faster.
For example encode all elements of a record of integer at the same time, so that they just need to be chained together to finis the coding work.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569215

Sometimes tests running in CI systems, do find problems ... that is why we have them, sometimes they fail because of circumstantial reasons unrealated to their purpose.
However after the failure, when investigating the issue ... it does matter how much information is available to the user/developer/person doing the debugging work.

Titan is in a unique position, where it is possible to maximize the information available automatically for the user.
What could be possible:
1)
Using XCoverage to drive the CI processes, when it notices a test failing ... it could re-execute the same test 2-3 more times.

This way next morning, when checking the log, it would be immediately known, if the test was failing consistently for the same reason (and so is most probably reproducible) or inconsistently ( most probably related to some environmental factor)

2)
Having control of the configuration file, it would be possible to run the test once with all logging options enabled ... to have more information in the logs.

3)
Using the version handling system it might be possible to identify which exact commit caused the test to fail.
And as Titan already supports an automatic refactoring feature, which is able to insert extra log statements into the code (logging all visible variables)...
It would be possible to create a version of the code, where before each changed line, the values of all visible variables would be logged ... do a compilation and execution.

---

This would also mean, that by default the tests could run with few log statements in the code, reducing logging settings in the configuration file ... optimized for runtime performance.
And the CI system could automatically enhance all of these settings to extract as much information as possible about the issue ... reducing the time needed to debug it.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569726

Simplify a ternary expression if the then and the else expressions are negative:

Given
return isActive ? isEnabled : !isEnabled;

When
Clean up the code enabling "Use '==' or '^' on booleans"

Then
return isActive == isEnabled;

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569202

The TTCN-3 IDE of TITAN might benefit from adding a new feature, that automatically logsin great detail the user's interaction with the IDE.
(for example: semantic checking frequency, duration, code completion contexts, menus invoked, preference pages visited, etc...)
Sending this data for processing would need user approval !

This way developers of the toolset would have a much more precise understanding of what features are actually used. Which features offers good solutions and which offer solutions that are rejected by the user.
This information could be used to improve the behaviour of parts with sub-optimal usage, optimize the code for actual real-world usage patterns and hopefully add new features that make the users life even better.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569207

Now that Object Orientation is becoming supported by both the TTCN-3 standard and Titan users will have an interesting problem:
They might wish to turn their existing code base object-oriented ... but there is just too much code to do this by hand.

Titan could offer a new refactoring solution, that can detect constructs that resemble class/object like behavior and try to extract classes out of them.

For example when a component has only a few fields, each of which is private, only read/written from functions running directly on the component ... that is mot probably an indication, that the developers of the code wanted to use a class ... but that was not possible.
In such situations, it might be possible to automatically create a class with the needed members and functions + remove the extracted members from the component and remove the extracted functions for the code.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569218

Right now when the C side of Titan encounter a syntactic or semantic issue in the code, there is no code generation.
On the Java side there is no code generation for the module containing the issue.

But it might be worth to investigate if it would be beneficial to generate code also for such modules.
It might not be obvious at first, but if the issue to fix is not big ... this would mean that all other modules could already be generated (even if the Java compiler will also report error).
This way once the issue is finally fix in TTCN-3 code ... only a small amount of generated Java code might still need to be compiled.
Which could lead to the user perceiving the build time, to be even faster than now.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=568916

Trying a parallel build with Tycho 2.1.0 results in the following message.

Can this part of the build also made thread-safe?



Warning:  *****************************************************************
Warning:  * Your build is requesting parallel execution, but project      *
Warning:  * contains the following plugin(s) that have goals not marked   *
Warning:  * as @threadSafe to support parallel building.                  *
Warning:  * While this /may/ work fine, please look for plugin updates    *
Warning:  * and/or request plugins be made thread-safe.                   *
Warning:  * If reporting an issue, report it against the plugin in        *
Warning:  * question, not against maven-core                              *
Warning:  *****************************************************************
Warning:  The following plugins are not marked @threadSafe in eclipse-2020-09:
Warning:  org.eclipse.tycho:tycho-packaging-plugin:2.1.0
Warning:  Enable debug to see more precisely which goals are not marked @threadSafe.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569587

The URL field of R package DESCRIPTION files support multiple URLs "separated by commas or whitespace".
RPkgDescription should directly offer a list of the URLs, so consumers doesn't have to take charge of splitting the URL string.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569203

Currently the ASCII doc documentation is using images whose file name is basically a number (refering to the section it is located in, and its order in the documentation).

This is not really maintenable.
As soon as someone inserts a new image somewhere, every image afterwards would have to have its name updated.
Also this makes it a bit hard to find specific images in the command line.

By reanming these image file, with names that properly reflect their actual content/purpose, it would be much easier to find in the command line ... and make it easier to maintain the documentation.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569682

This plugin only contains a prototype of a persistent revision cache. It has never proven to be correct and is, hence, not used.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569457

Currently it is possible to perform some general operations of the Titan plugins from command line, via headless operations.
This includes:
- clearing workspaces
- importing projects from .prj and .tpd files
- invoking the build command of projects
- exporting Titanium code smell information of projects, into excel and CSV files (and the data for SonarQube).
- exporting Titanium metric measurements of projects.
- exporting project structures as detected by Titanium, into .dot and .net formats.

With compiling via Java code now being supported and becoming evermore feature rich, the need for 1 more headless action is growing.
Exporting the built code into a jar file.

Currently we are able to invoke the build process from headless mode.
But when the build process is over, we are left with .class files in the working directory of the project.
To be more useful, we would need to have .jar files for execution.

Eclipse already offers a feature to export the resources (of a Java project) into a jar file as a wizard on the user interface.
This new headless application would need to invoke that functionality programmatically.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569075

Is it ok to move parts or all of it to wiki? I'm talking about documentation like

https://www.slideshare.net/oliviert/jdt-fundamentals-2010
https://www.eclipse.org/articles/article.php?file=Article-JavaCodeManipulation_AST/index.html

It is possible to convert the mediawiki representation into a eclipse help plugin if required.

It would be nice to have a little bit more than

https://help.eclipse.org/2020-09/index.jsp?topic=%2Forg.eclipse.jdt.doc.isv%2Fguide%2Fjdt_api_manip.htm&cp%3D3_0_0_1

in the wiki

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569354

Bug 568782 and Bug 568853 extended the ElementTypes metamodel to make it easier (and more readable) to create an ElementTypes Configuration model.

The generation of ElementTypes Configuration Models from a Profile should use these new concepts (i.e. a single ApplyAndMatchStereotype, directly owned by the SpecializedType, instead of one Matcher and one separate Advice)

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569213

We have enabled parallel semantic analysis in the Titan plugins recently.
Which greatly improves semantic checking and code quality checking times on modern (multi-core, multi-thread) processors.
The main reason behind this is simply the fact that in sequential execution the time of the complete duration of the analysis is the sum of the duration of analyzing single modules, while in parallel mode the number could be much smaller (in case there would be no dependencies between the modules it would be the maximum).

The logical step in this direction is to reduce the granularity of elements that are processed in parallel, to take more efficient care of the available processing power.
The idea here is that currently the limiting factor is the large imbalance in the module sizes that can appear in some project.
It could happen, that the project contains a large type description module with several hundred thousand lines of TTCN-3 code + several small TTCN-3 modules which only contain a few tests.
In such case the large module will have a dominating effect on the processing time, thanks to the over time being closely related to the max of the individual processing times (in case of dependencies there is still addition).

By improving the granularity and being able to analyze in parallel part of modules, this limitation would also be lifted.
In this case the large module itself could be processed in parallel on all available hardware cores/threads at the same time.

Bringing the overall utilization of the hardware closer to maximum, and processing time as low as possible.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=568990

The Xtend language UI uses preferences for syntax coloring. To support theme switches between dark and non-dark theme we have introduced a listener that subscribes the theme manager's themeChannged event (see https://github.com/eclipse/xtext-xtend/pull/1138).

IThemeManager is restricted API, but we would like to make this usage explicit by adding org.eclipse.xtend.ide as friendly user to the package.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=568883

Papyrus SW designer contains a M2M transformation supporting the code generation for state-machines. This transformation should also exist for Java.

Currently, the C++ state-machine library (not the transformation code) is located in the common transformation library. This should be changed in a preliminary step.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569206

Now that the Java side has both a native Java Main Controller, and can build native Java Host Controllers too, an interesting new opportunity is appearing to make test execution simpler.

It is possible to create a launching way, where the user only has to specify the cloud he wishes to use for the execution.
What can be done in such a situation:
- Titan is building the code, it knows if single mode execution is enough, or parallel mode execution is needed for a test.
- Titan could also have an informed guess on how many HC -s will be needed.
- As on the Java side Titan generates platform independent Java eecutables ... these could easily distributed in the could environment.
- From where the distributed HC -s could connect back the native Java MC for execution coordination.

And for the user this way of execution would be the most simple one possible.
He just has to select what to execute and in which cloud to use (could have a default setting on workbench level) ... and could start the execution.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569150

Don't use *inheritable* ThreadLocal.
Don't fork new threads in OCLExtentIterator.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=568994

Handly 1.5 needs to be compatible with Eclipse 2020-12. Notably, that includes Xtext 2.24.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569148

Provide an OMJob that can run in stand-alone or as Eclipse job.

Use this new class in org.eclipse.net4j.util.concurrent.TaskQueue<T> (see bug 568207).

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569711

This ticket splits the cleanups to a new tab that gathers all the cleanups related to a Java Feature. It helps to find cleanups, to select cleanups after a Java upgrade and perhaps will suggest Java backport in the future.

The tab content (at this time):

Java 15
Pattern matching for instanceof (Java 15 or higher with feature preview)

Java 14
Convert to switch expression

Java 10
Use local variable type inference

Java 8
Functional interface instances
Convert functional interface instances
Use lambda where possible
Use anonymous class
Use String.join() when possible

Java 7
Use try-with-resource
Use diamond operator
Use Objects.hash()
Use Objects.equals() in the equals method implementation

Java 5
Convert 'for' loops to enhanced
Only if loop variable used
Use Autoboxing
Use Unboxing

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569683

Currently we have in Titan 2 different project types.
One builds using C/C++, the other using Java.

Please remember to merge them later into a single one, as that would make it easier for our users to use our tools.

Right now it they are kept separately for 2 reasons:
- the Java side was until recently in prototype stage and we wished to keep it separated from the C side for this reason.
- this made the development of the Java side easier, as we could gradually build it up, without having to worry about all the feature we could not yet support.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569209

Right now Titan is only checking the TTCN-3 and ASN.1 code itself, but not the code comments within such file for quality.
This can create issues, where for example:
- the documentation of a function lists different formal parameters than the function has.
- the documentation is full of grammatical errors.
- the documentation might not actually belong to where it is currently placed

Titan should check for such anomalies.
It should be possible to check the the formal parameters listed in the documentation against the actual formal parameters using the semantic database present in the Eclipse plugins.
Also eclipse does offer grammatical checking for comments ... a functionality that might also be callable from the Designer plugin itself.
And with some NLP it might also be possible to detect if the documentation is describing something completely different from the function where it is located.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569151

Initial pages in the Properties dialog:
	Checkout
	Repository

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569135

Every time I'm working with developers that still debug by adding System.out.println() statements in production code I wonder why they don't use trace points.

I believe no one really realizes that this cool functionality is there at the mouse click, because there is no ruler menu action for "Toggle Tracepoint", only one for "Toggle Breakpoint", and the action under global Run -> Toggle Tracepoint is almost invisible because the "Run" menu is huge and the icons of "Toggle Tracepoint" is identical with one from "Toggle Breakpoint".

To increase discoverability of Toggle Tracepoint I propose to do both: add the Toggle Tracepoint action to the ruler and change the icon of the command.

I will push the patch.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569550

When increasing the line height for code mining, the text area should be changed so that the caret and the current line remain at the same location. Basically, the visible area should be shifted/scrolled getLineHeight() pixels down if possible

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569680

Provide a new method in CDOView:

  public Map<CDOID, CDOObject> getObjects(Collection<CDOID> ids)
  {
    Map<CDOID, CDOObject> result = CDOIDUtil.createMap();
    List<CDOID> missingIDs = new ArrayList<>();

    for (CDOID id : ids)
    {
      result.computeIfAbsent(id, i -> {
        InternalCDOObject object = getObject(i, false);
        if (object == null)
        {
          missingIDs.add(i);
        }

        return object;
      });
    }

    if (!missingIDs.isEmpty())
    {
      InternalCDOSession session = getSession();
      int initialChunkSize = session.options().getCollectionLoadingPolicy().getInitialChunkSize();

      CDORevisionManager revisionManager = session.getRevisionManager();
      List<CDORevision> revisions = revisionManager.getRevisions(missingIDs, this, initialChunkSize, CDORevision.DEPTH_NONE, true);

      for (CDORevision revision : revisions)
      {
        if (revision != null)
        {
          result.computeIfAbsent(revision.getID(), i -> getObject(i, false));
        }
      }
    }

    return result;
  }

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569666

Replaces (X && Y) || (X && Z) by (X && (Y || Y)).

Given:
boolean newBoolean = repeatedBoolean && !isValid || repeatedBoolean && isActive;

When:
Clean up the code enabling "Replace (X && Y) || (X && Z) by (X && (Y || Y))"

Then:
boolean newBoolean = (repeatedBoolean && (!isValid || isActive));

This feature is a part of the AutoRefactor plugin immigration into Eclipse
+--------------------------------------------------------------------+-----+
| Rule in AutoRefactor                                               |     |
+--------------------------------------------------------------------+-----+
| Add brackets to control statement                                  | OK  |
| All in one method rather than loop                                 | OK  |
| Arrays.fill() rather than loop                                     | OK  |
| Assign rather than control workflow then assign anyway             | OK  |
| Atomic object rather than mono index array                         | OK  |
| AutoBoxing rather than explicit method                             | OK  |
| Break rather than passive loops                                    | OK  |
| Collapse if statements                                             | OK  |
| Inited collection rather than new collection and Collection.add... | OK  |
| Diamond operator                                                   | OK  |
| Double negation                                                    | OK  |
| End of method rather than return                                   | OK  |
| Equals nullable                                                    | OK  |
| if-elseif                                                          | OK  |
| Improve lambda expressions                                         | OK  |
| Inited map rather than new map and Map.putAll()                    | OK  |
| Java 7 hash rather than Eclipse Java 6 hash                        | OK  |
| Lazy logical rather than eager                                     | OK  |
| Literal rather than boolean constant                               | OK  |
| Method on map rather than method on keyset                         | OK  |
| Merge conditional statements                                       | OK  |
| No assignment in if condition                                      | OK  |
| Number suffix in uppercase                                         | OK  |
| Objects equals rather than equals and null check                   | OK  |
| One code that falls through rather than redundant blocks           | OK  |
| Precompiles the regular expressions                                | OK  |
| Push negation down                                                 | OK  |
| Remove overridden assignment                                       | OK  |
| Remove semi-colons                                                 | OK  |
| Remove super() call in constructor                                 | OK  |
| Remove unnecessary casts                                           | OK  |
| Remove unneeded this expressions                                   | OK  |
| Remove useless lone continue at the end of a loop                  | OK  |
| Remove useless modifiers                                           | OK  |
| Replace String concatenation by StringBuilder when possible        | OK  |
| Serialize rather than boxing and serialize                         | OK  |
| Simple name rather than qualified name                             | OK  |
| String rather than new string                                      | OK  |
| String.join() rather than loop                                     | OK  |
| Switch                                                             | OK  |
| Ternary operator rather than duplicate conditions                  | OK  |
| Unboxing rather than explicit method                               | OK  |
| Use try-with-resource                                              | OK  |
| XOR rather than duplicate conditions                               | OK  |
| Extract common code in if else statement                           | ... |
| Operand factorization                                              | ... |
| Add underscore for each thousand in number literals when it is...  | ko  |
| Aggregate constructor rather than GWT method                       | ko  |
| Android ViewHolder                                                 | ko  |
| Android WakeLock                                                   | ko  |
| Annotation                                                         | ko  |
| ArrayDeque rather than Stack                                       | ko  |
| ArrayList rather than LinkedList                                   | ko  |
| ArrayList rather than Vector                                       | ko  |
| AssertJ                                                            | ko  |
| Assign rather than ternary filter then assign anyway               | ko  |
| Big number                                                         | ko  |
| Boolean                                                            | ko  |
| Boolean constant rather than valueOf()                             | ko  |
| Boolean equals() rather than null check                            | ko  |
| Boolean primitive rather than wrapper                              | ko  |
| Brackets rather than array instantiation                           | ko  |
| Byte primitive rather than wrapper                                 | ko  |
| Char primitive rather than wrapper                                 | ko  |
| Collection.addAll() rather than list creation                      | ko  |
| Collection.contains() rather than loop                             | ko  |
| Collection.containsAll() rather than loop                          | ko  |
| Collections APIs rather than Vector pre-Collections APIs           | ko  |
| Comments                                                           | ko  |
| Comparison to 0 rather than 1 or -1                                | ko  |
| Declaration outside loop rather than inside                        | ko  |
| Do/while rather than duplicate code                                | ko  |
| Do/while rather than while                                         | ko  |
| Double compare rather than equality                                | ko  |
| Double primitive rather than wrapper                               | ko  |
| Else rather than opposite condition                                | ko  |
| Empty test rather than size                                        | ko  |
| EnumMap rather than HashMap for enum keys                          | ko  |
| EnumSet rather than HashSet for enum types                         | ko  |
| Equals on constant rather than on variable                         | ko  |
| Float primitive rather than wrapper                                | ko  |
| Generic list rather than raw list                                  | ko  |
| Generic map rather than raw map                                    | ko  |
| HashMap rather than Hashtable                                      | ko  |
| HashMap rather than TreeMap                                        | ko  |
| HashSet rather than TreeSet                                        | ko  |
| If rather than two switch cases                                    | ko  |
| If rather than while and falls through                             | ko  |
| Implicit default constructor rather than written one               | ko  |
| Inline code rather than peremptory condition                       | ko  |
| instanceof rather than isInstance()                                | ko  |
| Int primitive rather than wrapper                                  | ko  |
| JUnit asserts                                                      | ko  |
| Jupiter asserts                                                    | ko  |
| Lambda expression rather than comparator                           | ko  |
| Local variable rather than field                                   | ko  |
| Log parameters rather than log message                             | ko  |
| Long primitive rather than wrapper                                 | ko  |
| Make inner class static if it doesn't use top level class members  | ko  |
| Map.entrySet() rather than Map.keySet() and value search           | ko  |
| Move common inner if statement from then/else clauses around ou... | ko  |
| Moves increment or decrement outside an expression when possible   | ko  |
| Multi-catch                                                        | ko  |
| Named method rather than log level parameter                       | ko  |
| No loop iteration rather than empty check                          | ko  |
| One condition rather than unreachable block                        | ko  |
| One if rather than duplicate blocks that fall through              | ko  |
| One try rather than two                                            | ko  |
| Opposite comparison rather than negative expression                | ko  |
| Opposite condition rather than duplicate condition                 | ko  |
| OR condition rather than redundant clauses                         | ko  |
| Primitive comparison rather than wrapper comparison                | ko  |
| Primitive wrapper creation                                         | ko  |
| Reduce indentation                                                 | ko  |
| Refactors a true or a false assertion with respectively an AND     | ko  |
| Redundant boolean                                                  | ko  |
| Redundant truth                                                    | ko  |
| Remove empty if                                                    | ko  |
| Remove empty lines                                                 | ko  |
| Remove fields default values                                       | ko  |
| Remove parenthesis                                                 | ko  |
| Remove unchecked exceptions from throws clause                     | ko  |
| Remove unnecessary local before return                             | ko  |
| Remove useless block                                               | ko  |
| Remove useless empty check before a for loop                       | ko  |
| Remove empty statements                                            | ko  |
| Replace for loop with Collections.disjoint(Collection, Collection) | ko  |
| Set rather than List                                               | ko  |
| Set rather than map                                                | ko  |
| Short primitive rather than wrapper                                | ko  |
| Single declarations rather than multi declaration                  | ko  |
| Standard method rather than Library method                         | ko  |
| Static constant rather than instance constant                      | ko  |
| String                                                             | ko  |
| String concatenation                                               | ko  |
| String.valueOf() rather than concatenation                         | ko  |
| StringBuilder method call rather than reassignment                 | ko  |
| StringBuilder rather than StringBuffer                             | ko  |
| substring() with one parameter rather than two                     | ko  |
| Super call rather than useless overriding                          | ko  |
| TestNG asserts                                                     | ko  |
| Update set rather than testing first                               | ko  |
| Use java.nio.* classes instead of java.io.* classes                | ko  |
| Use String.contains()                                              | ko  |
| Variable inside if rather than above                               | ko  |
| While condition rather than inner if                               | ko  |
+--------------------------------------------------------------------+-----+

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569281

I always find the need to have a "disable all breakpoints". I want to disable all existing breakpoints and add a new breakpoint. I tried control A  in breakpoint view and right click, select disable but it doesnt disable all if there are > 12 breakpoints. It only disables the breakpoint which are in view.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569496

In the Variables dialog (see attached image) the Gerrit user ID is requested. This value is later during the set up used for the SSH connection. Due to this has to correct otherwise the installation fails.

The issue is that on the Eclipse Gerrit user page, the listed ID is not what the installer needs. What the installer actually wants is the Username. 

Since the goal of the installer is to make the set up process as easy as possible i suggest change "Gerrit user ID" to "Gerrit username". This would have saved me some time.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569204

For larger projects working in TTCN-3 it is always a problem to test their code.
This is either done manually or by running automated tests that were written manually.

As Titan needs to both detect every issue in TTCN-3 codes and if there are none translate them to work binaries ... it understands such codes perfectly.
As such the semantic database and processing could be used to generate unit tests for TTCN-3 codes automatically.

It is important to mention, that this is not a feasible way to validate, that the test is performing its purpose as described in some documentation.
But:
- could be used to check if there are some instability issues within the test.
- before refactoring could be used to generate large amount of tests, using which it would be possible to show that the refactoring did not corrupt already existing functionalities.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569674

When I by accident generated a large log file, with the results of 100.000+ testcases it became apparent that the LogViewer plugin has some performance problems in relation to extracting the list of testcases.

In this case:
- it took several seconds (should be faster)
- the screen went white (should not be done in a display thread)
- displaying the list of testcases cluttered the navigator view (maybe some other form of organizing could be better for such large lists)

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569201

Titan already has a plugin for code quality improvement with refactoring.
This plugin however expects the user to be active and want to refactor something + to select what refactoring to perform + to select where it should be performed + review the result.

It is possible to create an automated functionality that can make this process simplier, by automatically searching for code quality improvement opportunities and offering them in some way to the user.
In such a situation when the user a few minutes for code quality improvement he would just need activate this feature ... + select the proposed solutions he finds good, while he has time for it.

The already implemented refactoring features could be extended to automatically search the code for place they could be potentially invoked with benefit.
This new feature would just need to invoke this functionality of each refactoring and offer the proposed solutions to the user, while he has time.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569630

(I am using Titan Designer Plugin 7/CAX 105 7730 R2A (7.2.pl0) but I could only select 7.1 in the menu.)

Our project is using ttcn3 modules from TCC_Releases. Our code depends on these modules, but they are not part of the project.

In the "Resources" tab, I can select which parts should be excluded or included in my project. As far as I can tell, if I turn on the on-the-fly checker, all modules in the project will get checked.

If I include the TCC_Releases modules in the project, I get reported Problems (errors/warnings) for these modules, which I do not want.

If I exclude the TCC_Releases modules from the project, they will not get parsed by the plug-in (it does not find modules outside of the project), so any imports will show up as broken.

I would like to be able to have the plug-in still parse all of the code (to allow for semantic check and jump-to-definition etc) but configure the on-the-fly checker to not report problems in all of the code. (For example, tell checker to only check or not check certain directories.)

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569196

Update T&T document with relevant items from N&N document.

To be validated with http://validator.w3.org/#validate_by_input before releasing.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=568995

Make sure that Handly is compatible with Xtext 2.24.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569402

see also the discussion here:

https://bugs.eclipse.org/bugs/show_bug.cgi?id=569372

WWD (or the lsp4j/lsp4e) uses language services to resolve stuff for them, like validation, code completion but also finding declarations (finding links)

That means that there is an IO operation to another process (nodejs) but the HyperLinkManager uses IHyperlinkDetector, that lsp4e implements, that should return:
IHyperlink[] detectHyperlinks(ITextViewer textViewer, IRegion region, boolean canShowMultipleHyperlinks);

problem is that this forces everything to be done in the ui thread, it would be nice if this interface would be reactive.

like that we can have IReactiveHyperlinkDetector:

CompletableFuture<IHyperlink[]> detectHyperlinks(ITextViewer textViewer, IRegion region, boolean canShowMultipleHyperlinks);

which a impl of IHyperlinkDetector can also extend and if that is the case HyperLinkManager  is working more async.

Problem is that for 1 file there can be more like 3 also a few legacy impls and HyperLinkManager wants in the end 1 list that it then wants to show.
So those impls maybe can be called also directly in the ui, but the actual show waits then for the fututure to complete first.
Or we have a default WrappingReactiveHyperlinkDetector  that just wraps the legacy once into one and also calls that outside of the ui thread
But his could be a bit tricky because of the param ITextViewer  where they get ui stuff from like the styledtext, and they are maybe not allowed to access UI stuff from outside of the ui thread.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569650

This enhancement request is about adding a new URIHandler at the head of the org.eclipse.emf.ecore.resource.URIHandler.DEFAULT_HANDLERS list. The new handler delegates all methods to a URIHandler that is registered in a new global registry. The delegate handler is selected purely on the scheme of the URI to be handled. The delegate handlers can be contributed to the global registry by declaring a contribution to the new extension point "org.eclipse.emf.ecore.uri_handler".

I'll submit a Gerrit review with the respective changes in a minute.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569357

The ElementTypes model can be quite complex, and it's easy to make mistakes, or introduce breaking changes, that are currently very difficult to detect.

We should add some validation rules for the model (Especially the Advices and Matchers). These rules should focus on the plug-in integration/deployment, rather than the model itself (So it will probably not be an EValidator extension; at least for some of the rules).

Some of these validation rules may already exist in the toolsmiths-dev branch; but we may have to refactor them to get a consistent build/validation API.

The rules include:

- Plugin deployment:
 - Ensure all the required plug-ins (GMF/Papyrus Element Types framework, referenced UML/Profile plug-ins, referenced ElementTypeSet Configurations...) are present in the Plug-in dependencies [1]
 - Ensure build.properties exports all the required files (or parent folder)
 - Ensure plugin.xml contains the required extension
- Model consistency:
 - Ensure the Advices are consistent with the current version of the profile (i.e. Profile URIs can be resolved in the workspace or installed plug-ins; Stereotype QualifiedNames exist; referenced Features exist...). Since this validator depends on the deployed plug-in (Which may be either installed, or simply present as a source plug-in in the workspace), I don't think it should be a model-validator.
- Model Validation
 - All these rules already exist (It's the EValidator). The EValidator should be invoked from the project builder [2]
 
Some similar work has been done for the Profile plug-ins (branch bugs/568495-staticprofile). We should use the same concepts/APIs. I think the profile branch doesn't contain model-validation rules; so maybe we'll need something specific for that. The Architecture validation (That will come later) will use similar concepts as well.

[1] Some of the dependencies validation rules already exist, at least in two places. One in ElementTypesConfigurationsValidator (AbstractEObjectDependencyValidator), that only checks the dependency corresponding to the extended Metamodel (i.e. UML2), and some in ElementTypesExternalDependenciesChecker. I think removing the ElementTypesConfigurationsValidator makes sense (And, later, the AbstractEObjectDependencyValidator); we should include this check in ElementTypesExternalDependenciesChecker. 

[2] There is already some code that triggers the model validation, and converts the resulting Diagnostic to Papyrus Build markers. However, it doesn't seem to report all errors; so I don't really know if it can be reused as-is, or needs to be updated/fixed. Also, EMF Markers should be removed when the Papyrus Builder runs, to avoid duplicate or obsolete markers.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569695

The error/warning icon overlays are clearly visible in the Package Exploter. Good.

I assumed that because it was 'new' / low priority there was no info equivalent making a localized upgrade campaign harder. Sigh.

However I have just noticed that there is an info overlay. Good. But it is just unfortunate that color and the vertical/horizontal of the icon "i" aligns with the bottom left lines of the typical rectangular document icon underneath. Only a couple of pixels around the "." at the top of the "i" are visible.

Suggest: redesign the icon as an 7x7 blue square border with an "i" inside so that the outer border is visible.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569480

Typing some random string in Ctrl+3 dialog should show a "Search 'randomString' in files", "Search 'randomString' in folder/" (where folder/ is the current selection, when appropriate) something like that, that would immediately trigger a workspace search. It would allow Ctrl+3 to replace many occurrences of Ctrl+h.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569694

I have recently run into an interesting new tool called TornadoVM.
The developers claim that it is just like a normal Java VM, but is able to automatically translate the code to graphic cards ... enabling large parformance improvements.

more information: https://jjfumero.github.io/files/Joker2019-TornadoVM_JuanFumero.pdf

I believe Titan should try it out, to see if the Java side could benefit from this.
Right now the Java side is faster than the C side for normal testing scenarios.
But if the encoder/decoder functions could be run on graphic cards (automatically if present), that could boost the Java side to be the primary platform for performance testing scenarios too.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=568993

Some source file implementations may sometimes be unusually slow in building their structure (seconds). We'll add a new API for fetching children of an element to a collector. By default, it will be implemented via #getChildren; model implementors will be able to override the default implementation. The API will be leveraged by DeferredElementTreeContentProvider (bug 568496).

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569572

Provide a URIHandler that allows to open a model editor on a CDOFileResource in a CDOCheckout.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569154

Provide CDOBranchRef.MAIN and CDOBranchPointRef.MAIN_HEAD constants and also a CDOBranchRef.getHeadRef() method.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569026

Today when searching, specially when creating the type hierarchy the indexes are searched sequentially. The search can be improved if these index search are done parallel using the ForkJoinExecutor to use the potential of the underlying running hardware. 

I have done some tests with some visualvm sampling. Will publish the results soon with a patch of my improvement. My main target was to improve type hierarchy build time in larger projects which has may transitive dependencies. But the change benefit other kind of search operations as well.

I think we can go one step further later by making the type hierarchy UI asynchronous.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569235

JDT lts, JDT debug, PDE and lots of platform plug-ins have updated to Java 11, I suggest that JDT core does the same.

This would allow to use JEP-180to improve performance. See https://git.eclipse.org/r/c/jdt/eclipse.jdt.core/+/169915/2/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/KeyOfCharArray.java Only Java 9 would be required but as this is already out, moving to Java 11 means reasonable.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569546

Provide a menu item "File > Open Workspace" to launch multiple workspaces from Eclipse IDE without closing the current workspace.

See discussion on https://www.eclipse.org/lists/platform-dev/msg02600.html and the macOS implementation in https://github.com/turesheim/eclipse-launcher.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569541

For Eclipse project, we're working on a CI job to vote -1 on Gerrit during our freeze periods. It would seem more convenient that this vote gets pushed by another "bot" than the use we typically use for build+test.
Is it possible to add into Platform Jenkins instance some new Gerrit user "Freeze Bot" with permission to comment and vote on all equinox/*, platform/*, jdt/* and pde/* repositories?

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569155

org.eclipse.emf.cdo.view.CDOViewSet.CDOViewSetException

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569356

Once Bug 569354 is done, we should add support for regenerating an ElementTypesConfiguration model, after the Profile has changed. Currently, a new model would be created, overriding the existing one (and any custom modifications/additions).

The regeneration should preserve manual changes as much as possible. Since we have a one-to-one mapping between Stereotypes and (generated) SpecializationType/Advices, the regeneration algorithm probably doesn't need to be too smart/generic. Especially:

- Deleted Stereotypes should result in the suppression of the corresponding ElementType and target Advices
- Added Stereotypes should result in the addition of the corresponding ElementType and Advice
- Renamed Stereotype should result in the renaming of the SpecializationType ID. Generated Advices should be updated (to match the new Stereotype QName) and Custom Advices should be preserved. If custom advices are related to the renamed Stereotype; we may update the QNames as well.

We should also try to recover the previously entered values for the target folder and the ElementTypeSet ID (Preferably without having to persist some additional metadata).

Other (smarter/more complex) updates are not necessary, and should be covered by validation rules instead (e.g. if an advice, unrelated to one of the generated element types, references a Stereotype that no longer exists).

In terms of UI, we may add a few options to the wizard:

- (Boolean) Regenerate from scratch (i.e. not incrementally; that's the current behavior)
- (Boolean) Preserve ElementTypes/Advices related to deleted stereotypes (So the user may choose to either fix them manually, or remove them if they no longer make sense).
- Other?

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=568939

There are a few association-end constraints that do not show in class diagrams as association-end labels after the fashion of the name and multiplicity. When using UML class modeling for metamodels, these are particularly important and I find myself always adding GMF Text views to the diagram to fake them:

- subsets:  e.g., "{ subsets ownedElement }"
- redefinitions: e.g., "{ redefines general }"

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=568865

Currently it is not possible to edit child items of custom target platform items. There are some codes to support this for IU locations but this is all internal and can't be reused.

7498217498122 URL = https://bugs.eclipse.org/bugs/show_bug.cgi?id=569195

Update T&T document with relevant items from N&N document.

To be validated with http://validator.w3.org/#validate_by_input before releasing.

